{"version":3,"file":"pixi-picture.es.js","sources":["../src/BlendFilter.ts","../src/FlipYFilter.ts","../src/MaskFilter.ts","../src/ShaderParts.ts","../src/FilterSystemMixin.ts","../src/index.ts"],"sourcesContent":["import {Filter} from '@pixi/core';\r\n\r\nexport class BackdropFilter extends Filter {\r\n    backdropUniformName: string = null;\r\n    _backdropActive: boolean = false;\r\n    clearColor: Float32Array = null;\r\n}\r\n\r\nexport interface IBlendShaderParts {\r\n    uniformCode?: string;\r\n    uniforms?: { [key: string]: any };\r\n    blendCode: string;\r\n}\r\n\r\nconst filterFrag = `\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D uBackdrop;\r\nuniform vec2 uBackdrop_flipY;\r\n\r\n%UNIFORM_CODE%\r\n\r\nvoid main(void)\r\n{\r\n   vec2 backdropCoord = vec2(vTextureCoord.x, uBackdrop_flipY.x + uBackdrop_flipY.y * vTextureCoord.y);\r\n   vec4 b_src = texture2D(uSampler, vTextureCoord);\r\n   vec4 b_dest = texture2D(uBackdrop, backdropCoord);\r\n   vec4 b_res = b_dest;\r\n   \r\n   %BLEND_CODE%\r\n\r\n   gl_FragColor = b_res;\r\n}`;\r\n\r\nexport class BlendFilter extends BackdropFilter {\r\n    constructor(shaderParts: IBlendShaderParts) {\r\n        let fragCode = filterFrag;\r\n        fragCode = fragCode.replace('%UNIFORM_CODE%', shaderParts.uniformCode || \"\");\r\n        fragCode = fragCode.replace('%BLEND_CODE%', shaderParts.blendCode || \"\");\r\n\r\n        super(undefined, fragCode, shaderParts.uniforms);\r\n\r\n        this.backdropUniformName = 'uBackdrop';\r\n    }\r\n}\r\n","import {Filter} from '@pixi/core';\r\nimport type {Dict} from '@pixi/utils';\r\n\r\nconst vert = `\r\nattribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\nuniform vec2 flipY;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n    vTextureCoord.y = flipY.x + flipY.y * vTextureCoord.y;\r\n}\r\n\r\n`;\r\n\r\nexport class FlipYFilter extends Filter {\r\n\tconstructor(frag?: string, uniforms?: Dict<any>) {\r\n\t\tconst uni = uniforms || {};\r\n\t\tif (!uni.flipY) {\r\n\t\t\tuni.flipY = new Float32Array([0.0, 1.0]);\r\n\t\t}\r\n\t\tsuper(vert, frag, uni);\r\n\t}\r\n}\r\n","import {FilterSystem, RenderTexture, Filter} from '@pixi/core';\r\nimport {BLEND_MODES, CLEAR_MODES} from '@pixi/constants';\r\nimport {BlendFilter} from \"./BlendFilter\";\r\nimport {FlipYFilter} from \"./FlipYFilter\";\r\n\r\nexport enum MASK_CHANNEL {\r\n\tRED = 0,\r\n\tGREEN,\r\n\tBLUE,\r\n\tALPHA\r\n}\r\n\r\nexport class MaskConfig {\r\n\tconstructor(public maskBefore = false, channel: MASK_CHANNEL = MASK_CHANNEL.ALPHA) {\r\n\t\tthis.uniforms.uChannel[channel] = 1.0;\r\n\t}\r\n\r\n\tuniformCode = 'uniform vec4 uChannel;';\r\n\tuniforms: any = {\r\n\t\tuChannel: new Float32Array([0, 0, 0, 0]), // shared uniform for all those shaders? ok, just set it before apply\r\n\t};\r\n\tblendCode = `b_res = dot(b_src, uChannel) * b_dest;`;\r\n\tsafeFlipY = false;\r\n}\r\n\r\nconst tmpArray = new Float32Array([0, 1]);\r\n\r\nexport class MaskFilter extends BlendFilter {\r\n\tconstructor(public baseFilter: Filter, public config = new MaskConfig()) {\r\n\t\tsuper(config);\r\n\t\tthis.padding = baseFilter.padding;\r\n\t\tthis.safeFlipY = config.safeFlipY;\r\n\t}\r\n\r\n\tstatic _flipYFilter: FlipYFilter = null;\r\n\t/**\r\n\t * if base filter is not sensitive to flipping Y axis, you can turn this ON and save a temporary texture bind / drawcall\r\n\t */\r\n\tsafeFlipY: boolean;\r\n\r\n\tapply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\r\n\t      clearMode: CLEAR_MODES) {\r\n\t\tconst target = filterManager.getFilterTexture(input);\r\n\t\tif (this.config.maskBefore) {\r\n\t\t\tconst {blendMode} = this.state;\r\n\t\t\tthis.state.blendMode = BLEND_MODES.NONE;\r\n\t\t\tfilterManager.applyFilter(this, input, target, CLEAR_MODES.YES);\r\n\t\t\tthis.baseFilter.blendMode = blendMode;\r\n\t\t\tthis.baseFilter.apply(filterManager, target, output, clearMode);\r\n\t\t\tthis.state.blendMode = blendMode;\r\n\t\t} else {\r\n\t\t\tconst {uBackdrop, uBackdrop_flipY} = this.uniforms;\r\n\r\n\t\t\tif (uBackdrop_flipY[1] > 0 || this.safeFlipY) {\r\n\t\t\t\tthis.baseFilter.apply(filterManager, uBackdrop, target, CLEAR_MODES.YES);\r\n\t\t\t} else {\r\n\t\t\t\t// in case there was a flip and base filter is not flipY-safe, we have to use extra flip operation\r\n\t\t\t\tconst targetFlip = filterManager.getFilterTexture(input);\r\n\t\t\t\tif (!MaskFilter._flipYFilter) {\r\n\t\t\t\t\tMaskFilter._flipYFilter = new FlipYFilter();\r\n\t\t\t\t}\r\n\t\t\t\tMaskFilter._flipYFilter.uniforms.flipY[0] = uBackdrop_flipY[0];\r\n\t\t\t\tMaskFilter._flipYFilter.uniforms.flipY[1] = uBackdrop_flipY[1];\r\n\t\t\t\tMaskFilter._flipYFilter.apply(filterManager, uBackdrop, targetFlip, CLEAR_MODES.YES);\r\n\t\t\t\tthis.baseFilter.apply(filterManager, targetFlip, target, CLEAR_MODES.YES);\r\n\t\t\t\tfilterManager.returnFilterTexture(targetFlip);\r\n\t\t\t\tthis.uniforms.uBackdrop_flipY = tmpArray;\r\n\t\t\t}\r\n\t\t\tthis.uniforms.uBackdrop = target;\r\n\t\t\tfilterManager.applyFilter(this, input, output, clearMode);\r\n\t\t\tthis.uniforms.uBackdrop = uBackdrop;\r\n\t\t\tthis.uniforms.uBackdrop_flipY = uBackdrop_flipY;\r\n\t\t}\r\n\t\tfilterManager.returnFilterTexture(target);\r\n\t}\r\n}\r\n","import {BlendFilter} from \"./BlendFilter\";\r\nimport {BLEND_MODES} from \"@pixi/constants\";\r\n\r\nexport const NPM_BLEND: string =\r\n    `if (b_src.a == 0.0) {\r\n  gl_FragColor = vec4(0, 0, 0, 0);\r\n  return;\r\n}\r\nif (b_dest.a == 0.0) {\r\n  gl_FragColor = b_src;\r\n  return;\r\n}\r\nvec3 Cb = b_dest.rgb / b_dest.a;\r\nvec3 Cs = b_src.rgb / b_src.a;\r\n%NPM_BLEND%\r\nb_res.a = b_src.a + b_dest.a * (1.0-b_src.a);\r\nb_res.rgb = (1.0 - b_dest.a) * Cs + b_dest.a * B;\r\nb_res.rgb *= b_res.a;\r\n`;\r\n\r\n//reverse hardlight\r\nexport const OVERLAY_PART: string =\r\n    `vec3 multiply = Cb * Cs * 2.0;\r\nvec3 Cb2 = Cb * 2.0 - 1.0;\r\nvec3 screen = Cb2 + Cs - Cb2 * Cs;\r\nvec3 B;\r\nif (Cs.r <= 0.5) {\r\n  B.r = multiply.r;\r\n} else {\r\n  B.r = screen.r;\r\n}\r\nif (Cs.g <= 0.5) {\r\n  B.g = multiply.g;\r\n} else {\r\n  B.g = screen.g;\r\n}\r\nif (Cs.b <= 0.5) {\r\n  B.b = multiply.b;\r\n} else {\r\n  B.b = screen.b;\r\n}\r\n`;\r\n\r\nexport const HARDLIGHT_PART: string =\r\n    `vec3 multiply = Cb * Cs * 2.0;\r\nvec3 Cs2 = Cs * 2.0 - 1.0;\r\nvec3 screen = Cb + Cs2 - Cb * Cs2;\r\nvec3 B;\r\nif (Cb.r <= 0.5) {\r\n  B.r = multiply.r;\r\n} else {\r\n  B.r = screen.r;\r\n}\r\nif (Cb.g <= 0.5) {\r\n  B.g = multiply.g;\r\n} else {\r\n  B.g = screen.g;\r\n}\r\nif (Cb.b <= 0.5) {\r\n  B.b = multiply.b;\r\n} else {\r\n  B.b = screen.b;\r\n}\r\n`;\r\n\r\nexport const SOFTLIGHT_PART: string =\r\n    `vec3 first = Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\r\nvec3 B;\r\nvec3 D;\r\nif (Cs.r <= 0.5)\r\n{\r\n  B.r = first.r;\r\n}\r\nelse\r\n{\r\n  if (Cb.r <= 0.25)\r\n  {\r\n    D.r = ((16.0 * Cb.r - 12.0) * Cb.r + 4.0) * Cb.r;    \r\n  }\r\n  else\r\n  {\r\n    D.r = sqrt(Cb.r);\r\n  }\r\n  B.r = Cb.r + (2.0 * Cs.r - 1.0) * (D.r - Cb.r);\r\n}\r\nif (Cs.g <= 0.5)\r\n{\r\n  B.g = first.g;\r\n}\r\nelse\r\n{\r\n  if (Cb.g <= 0.25)\r\n  {\r\n    D.g = ((16.0 * Cb.g - 12.0) * Cb.g + 4.0) * Cb.g;    \r\n  }\r\n  else\r\n  {\r\n    D.g = sqrt(Cb.g);\r\n  }\r\n  B.g = Cb.g + (2.0 * Cs.g - 1.0) * (D.g - Cb.g);\r\n}\r\nif (Cs.b <= 0.5)\r\n{\r\n  B.b = first.b;\r\n}\r\nelse\r\n{\r\n  if (Cb.b <= 0.25)\r\n  {\r\n    D.b = ((16.0 * Cb.b - 12.0) * Cb.b + 4.0) * Cb.b;    \r\n  }\r\n  else\r\n  {\r\n    D.b = sqrt(Cb.b);\r\n  }\r\n  B.b = Cb.b + (2.0 * Cs.b - 1.0) * (D.b - Cb.b);\r\n}\r\n`;\r\n\r\nexport const MULTIPLY_PART: string =\r\n    `vec3 B = Cs * Cb;\r\n`;\r\nexport const OVERLAY_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, OVERLAY_PART);\r\nexport const HARDLIGHT_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, HARDLIGHT_PART);\r\nexport const SOFTLIGHT_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, SOFTLIGHT_PART);\r\nexport const MULTIPLY_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, MULTIPLY_PART);\r\n\r\nexport const blendFullArray: Array<string> = [];\r\n\r\nblendFullArray[BLEND_MODES.MULTIPLY] = MULTIPLY_FULL;\r\nblendFullArray[BLEND_MODES.OVERLAY] = OVERLAY_FULL;\r\nblendFullArray[BLEND_MODES.HARD_LIGHT] = HARDLIGHT_FULL;\r\nblendFullArray[BLEND_MODES.SOFT_LIGHT] = SOFTLIGHT_FULL;\r\n\r\nlet filterCache: Array<BlendFilter> = [];\r\nlet filterCacheArray: Array<Array<BlendFilter>> = [];\r\n\r\nexport function getBlendFilter(blendMode: BLEND_MODES) {\r\n    if (!blendFullArray[blendMode]) {\r\n        return null;\r\n    }\r\n    if (!filterCache[blendMode]) {\r\n        filterCache[blendMode] = new BlendFilter({blendCode: blendFullArray[blendMode]});\r\n    }\r\n    return filterCache[blendMode];\r\n}\r\n\r\nexport function getBlendFilterArray(blendMode: BLEND_MODES) {\r\n    if (!blendFullArray[blendMode]) {\r\n        return null;\r\n    }\r\n    if (!filterCacheArray[blendMode]) {\r\n        filterCacheArray[blendMode] = [getBlendFilter(blendMode)];\r\n    }\r\n    return filterCacheArray[blendMode];\r\n}\r\n","import {TextureSystem, FilterSystem, BaseTexture, RenderTexture, Filter, FilterState} from '@pixi/core';\r\nimport {CLEAR_MODES} from '@pixi/constants';\r\nimport {Matrix, Rectangle} from '@pixi/math';\r\nimport {DisplayObject} from '@pixi/display';\r\nimport {BackdropFilter} from \"./BlendFilter\";\r\n\r\nexport interface IPictureFilterSystem extends FilterSystem {\r\n    prepareBackdrop(sourceFrame: Rectangle, flipY: Float32Array): RenderTexture;\r\n\r\n    pushWithCheck(target: DisplayObject, filters: Array<Filter>, checkEmptyBounds?: boolean): boolean;\r\n}\r\n\r\nexport interface IPictureTextureSystem extends TextureSystem {\r\n    bindForceLocation(texture: BaseTexture, location: number): void;\r\n}\r\n\r\nfunction containsRect(rectOut: Rectangle, rectIn: Rectangle): boolean {\r\n    let r1 = rectIn.x + rectIn.width;\r\n    let b1 = rectIn.y + rectIn.height;\r\n    let r2 = rectOut.x + rectOut.width;\r\n    let b2 = rectOut.y + rectOut.height;\r\n    return (rectIn.x >= rectOut.x) &&\r\n        (rectIn.x <= r2) &&\r\n        (rectIn.y >= rectOut.y) &&\r\n        (rectIn.y <= b2) &&\r\n        (r1 >= rectOut.x) &&\r\n        (r1 <= r2) &&\r\n        (b1 >= rectOut.y) &&\r\n        (b1 <= b2);\r\n}\r\n\r\nfunction bindForceLocation(this: IPictureTextureSystem, texture: BaseTexture, location = 0) {\r\n    const { gl } = this;\r\n    if (this.currentLocation !== location)\r\n    {\r\n        this.currentLocation = location;\r\n        gl.activeTexture(gl.TEXTURE0 + location);\r\n    }\r\n    this.bind(texture, location);\r\n}\r\n\r\nconst tempMatrix = new Matrix();\r\n\r\nfunction pushWithCheck(this: IPictureFilterSystem,\r\n              target: DisplayObject, filters: Array<BackdropFilter>, checkEmptyBounds: boolean = true) {\r\n    const renderer = this.renderer;\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = this.statePool.pop() || new FilterState();\r\n    const renderTextureSystem = this.renderer.renderTexture;\r\n\r\n    let resolution = filters[0].resolution;\r\n    let padding = filters[0].padding;\r\n    let autoFit = filters[0].autoFit;\r\n    let legacy = filters[0].legacy;\r\n\r\n    for (let i = 1; i < filters.length; i++)\r\n    {\r\n        const filter = filters[i];\r\n\r\n        resolution = Math.min(resolution, filter.resolution);\r\n        padding = this.useMaxPadding\r\n            ? Math.max(padding, filter.padding)\r\n            : padding + filter.padding;\r\n        autoFit = autoFit && filter.autoFit;\r\n\r\n        legacy = legacy || filter.legacy;\r\n    }\r\n\r\n    if (filterStack.length === 1)\r\n    {\r\n        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\r\n    }\r\n\r\n    filterStack.push(state);\r\n\r\n    state.resolution = resolution;\r\n\r\n    state.legacy = legacy;\r\n\r\n    state.target = target;\r\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\r\n\r\n    state.sourceFrame.pad(padding);\r\n\r\n    let canUseBackdrop = true;\r\n    if (autoFit)\r\n    {\r\n        const sourceFrameProjected = (this as any).tempRect.copyFrom(renderTextureSystem.sourceFrame);\r\n\r\n        // Project source frame into world space (if projection is applied)\r\n        if (renderer.projection.transform)\r\n        {\r\n            (this as any).transformAABB(\r\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\r\n                sourceFrameProjected\r\n            );\r\n        }\r\n\r\n        state.sourceFrame.fit(sourceFrameProjected);\r\n    } else {\r\n        //check if backdrop is obtainable after rejecting autoFit\r\n        canUseBackdrop = containsRect(this.renderer.renderTexture.sourceFrame, state.sourceFrame);\r\n    }\r\n\r\n    if (checkEmptyBounds && state.sourceFrame.width <= 1 && state.sourceFrame.height <= 1) {\r\n        filterStack.pop();\r\n        state.clear();\r\n        this.statePool.push(state);\r\n        return false;\r\n    }\r\n    (this as any).roundFrame(\r\n        state.sourceFrame,\r\n        renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\r\n        renderTextureSystem.sourceFrame,\r\n        renderTextureSystem.destinationFrame,\r\n        renderer.projection.transform,\r\n    );\r\n\r\n    // round to whole number based on resolution\r\n    state.sourceFrame.ceil(resolution);\r\n\r\n    // detect backdrop uniform\r\n    if (canUseBackdrop) {\r\n        let backdrop = null;\r\n        let backdropFlip = null;\r\n        for (let i = 0; i < filters.length; i++) {\r\n            const bName = filters[i].backdropUniformName;\r\n            if (bName) {\r\n                const { uniforms } = filters[i];\r\n                if (!uniforms[bName + '_flipY']) {\r\n                    uniforms[bName + '_flipY'] = new Float32Array([0.0, 1.0]);\r\n                }\r\n                const flip = uniforms[bName + '_flipY'];\r\n                if (backdrop === null) {\r\n                    backdrop = this.prepareBackdrop(state.sourceFrame, flip);\r\n                    backdropFlip = flip;\r\n                } else {\r\n                    flip[0] = backdropFlip[0];\r\n                    flip[1] = backdropFlip[1];\r\n                }\r\n\r\n                uniforms[bName] = backdrop;\r\n                if (backdrop) {\r\n                    filters[i]._backdropActive = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (backdrop)\r\n        {\r\n            resolution = state.resolution = backdrop.resolution;\r\n        }\r\n    }\r\n\r\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);\r\n    state.filters = filters;\r\n\r\n    state.destinationFrame.width = state.renderTexture.width;\r\n    state.destinationFrame.height = state.renderTexture.height;\r\n\r\n    const destinationFrame = (this as any).tempRect;\r\n\r\n    destinationFrame.x = 0;\r\n    destinationFrame.y = 0;\r\n    destinationFrame.width = state.sourceFrame.width;\r\n    destinationFrame.height = state.sourceFrame.height;\r\n\r\n    state.renderTexture.filterFrame = state.sourceFrame;\r\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\r\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\r\n\r\n    state.transform = renderer.projection.transform;\r\n    renderer.projection.transform = null;\r\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\r\n\r\n    const cc = filters[filters.length - 1].clearColor as any;\r\n\r\n    if (cc) {\r\n        // take clear color from filter, it helps for advanced DisplacementFilter\r\n        renderer.framebuffer.clear(cc[0], cc[1], cc[2], cc[3]);\r\n    } else {\r\n        renderer.framebuffer.clear(0, 0, 0, 0);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction push(this: IPictureFilterSystem,\r\n              target: DisplayObject, filters: Array<Filter>) {\r\n    return this.pushWithCheck(target, filters, false);\r\n}\r\n\r\nfunction pop(this: IPictureFilterSystem) {\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = filterStack.pop();\r\n    const filters = state.filters as Array<BackdropFilter>;\r\n\r\n    this.activeState = state;\r\n\r\n    const globalUniforms = this.globalUniforms.uniforms;\r\n\r\n    globalUniforms.outputFrame = state.sourceFrame;\r\n    globalUniforms.resolution = state.resolution;\r\n\r\n    const inputSize = globalUniforms.inputSize;\r\n    const inputPixel = globalUniforms.inputPixel;\r\n    const inputClamp = globalUniforms.inputClamp;\r\n\r\n    inputSize[0] = state.destinationFrame.width;\r\n    inputSize[1] = state.destinationFrame.height;\r\n    inputSize[2] = 1.0 / inputSize[0];\r\n    inputSize[3] = 1.0 / inputSize[1];\r\n\r\n    inputPixel[0] = inputSize[0] * state.resolution;\r\n    inputPixel[1] = inputSize[1] * state.resolution;\r\n    inputPixel[2] = 1.0 / inputPixel[0];\r\n    inputPixel[3] = 1.0 / inputPixel[1];\r\n\r\n    inputClamp[0] = 0.5 * inputPixel[2];\r\n    inputClamp[1] = 0.5 * inputPixel[3];\r\n    inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\r\n    inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\r\n\r\n    // only update the rect if its legacy..\r\n    if (state.legacy)\r\n    {\r\n        const filterArea = globalUniforms.filterArea;\r\n\r\n        filterArea[0] = state.destinationFrame.width;\r\n        filterArea[1] = state.destinationFrame.height;\r\n        filterArea[2] = state.sourceFrame.x;\r\n        filterArea[3] = state.sourceFrame.y;\r\n\r\n        globalUniforms.filterClamp = globalUniforms.inputClamp;\r\n    }\r\n\r\n    this.globalUniforms.update();\r\n\r\n    const lastState = filterStack[filterStack.length - 1];\r\n\r\n    if (state.renderTexture.framebuffer.multisample > 1)\r\n    {\r\n        this.renderer.framebuffer.blit();\r\n    }\r\n\r\n    if (filters.length === 1)\r\n    {\r\n        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(state.renderTexture);\r\n    }\r\n    else\r\n    {\r\n        let flip = state.renderTexture;\r\n        let flop = this.getOptimalFilterTexture(\r\n            flip.width,\r\n            flip.height,\r\n            state.resolution\r\n        );\r\n\r\n        flop.filterFrame = flip.filterFrame;\r\n\r\n        let i = 0;\r\n\r\n        for (i = 0; i < filters.length - 1; ++i)\r\n        {\r\n            filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\r\n\r\n            const t = flip;\r\n\r\n            flip = flop;\r\n            flop = t;\r\n        }\r\n\r\n        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(flip);\r\n        this.returnFilterTexture(flop);\r\n    }\r\n\r\n    // release the backdrop!\r\n    let backdropFree = false;\r\n\r\n    for (let i = 0; i < filters.length; i++) {\r\n        if (filters[i]._backdropActive) {\r\n            const bName = filters[i].backdropUniformName;\r\n            if (!backdropFree) {\r\n                this.returnFilterTexture(filters[i].uniforms[bName]);\r\n                backdropFree = true;\r\n            }\r\n            filters[i].uniforms[bName] = null;\r\n            filters[i]._backdropActive = false;\r\n        }\r\n    }\r\n\r\n    state.clear();\r\n    this.statePool.push(state);\r\n}\r\n\r\nlet hadBackbufferError = false;\r\n\r\n/**\r\n * Takes a part of current render target corresponding to bounds\r\n * fits sourceFrame to current render target frame to evade problems\r\n */\r\nfunction prepareBackdrop(bounds: Rectangle, flipY: Float32Array): RenderTexture {\r\n    const renderer = this.renderer;\r\n    const renderTarget = renderer.renderTexture.current;\r\n    const fr = this.renderer.renderTexture.sourceFrame;\r\n    const tf = renderer.projection.transform || Matrix.IDENTITY;\r\n\r\n    //TODO: take non-standart sourceFrame/destinationFrame into account, all according to ShukantPal refactoring\r\n\r\n    let resolution = 1;\r\n    if (renderTarget) {\r\n        resolution = renderTarget.baseTexture.resolution;\r\n        flipY[1] = 1.0;\r\n    } else {\r\n        if (!renderer.useContextAlpha) {\r\n            if (!hadBackbufferError) {\r\n                hadBackbufferError = true;\r\n                console.warn('pixi-picture: you are trying to use Blend Filter on main framebuffer! That wont work.');\r\n            }\r\n            return null;\r\n        }\r\n        resolution = renderer.resolution;\r\n        flipY[1] = -1.0;\r\n    }\r\n\r\n    //bounds.fit(fr);\r\n\r\n    const x = Math.round((bounds.x - fr.x + tf.tx) * resolution);\r\n    const dy = bounds.y - fr.y + tf.ty;\r\n    const y = Math.round((flipY[1] < 0.0 ? fr.height - (dy + bounds.height) : dy) * resolution);\r\n    const w = Math.round(bounds.width * resolution);\r\n    const h = Math.round(bounds.height * resolution);\r\n\r\n    const gl = renderer.gl;\r\n    const rt = this.getOptimalFilterTexture(w, h, 1);\r\n\r\n    if (flipY[1] < 0) {\r\n        flipY[0] = h / rt.height;\r\n    }\r\n\r\n    rt.filterFrame = fr;\r\n    rt.setResolution(resolution);\r\n    renderer.texture.bindForceLocation(rt.baseTexture, 0);\r\n    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, w, h);\r\n    return rt;\r\n}\r\n\r\nexport function applyMixins() {\r\n    (TextureSystem as any).prototype.bindForceLocation = bindForceLocation;\r\n    (FilterSystem as any).prototype.push = push;\r\n    (FilterSystem as any).prototype.pushWithCheck = pushWithCheck as any;\r\n    (FilterSystem as any).prototype.pop = pop;\r\n    (FilterSystem as any).prototype.prepareBackdrop = prepareBackdrop;\r\n}\r\n","export * from './BlendFilter';\r\nexport * from './FlipYFilter';\r\nexport * from './MaskFilter';\r\nexport * from './ShaderParts';\r\nexport * from './Sprite';\r\nexport * from './TilingSprite';\r\nimport {IPictureFilterSystem, IPictureTextureSystem, applyMixins} from \"./FilterSystemMixin\";\r\nexport {IPictureFilterSystem, IPictureTextureSystem, applyMixins};\r\n\r\napplyMixins();\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACEA;;;;;AAKA;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+FR;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;AAUA;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IA;;;;;;;;;;;;;AAaA;AAEA;;;;;;;AAQA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8IA;AAEA;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyGA;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;;;;;;;AAQA;;AC5VA;;;;"}