/*!
 * @pixi/graphics-extras - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/graphics-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
import { Graphics } from '@pixi/graphics';
import { Polygon, PI_2 } from '@pixi/math';

/**
 * Draw a torus shape, like a donut. Can be used for something like a circle loader.
 *
 * _Note: Only available with **@pixi/graphics-extras**._
 *
 * @method PIXI.Graphics#drawTorus
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} innerRadius - Inner circle radius
 * @param {number} outerRadius - Outer circle radius
 * @param {number} [startArc=0] - Where to begin sweep, in radians, 0.0 = to the right
 * @param {number} [endArc=Math.PI*2] - Where to end sweep, in radians
 * @return {PIXI.Graphics}
 */
function drawTorus(x, y, innerRadius, outerRadius, startArc, endArc) {
    if (startArc === void 0) { startArc = 0; }
    if (endArc === void 0) { endArc = Math.PI * 2; }
    if (Math.abs(endArc - startArc) >= Math.PI * 2) {
        return this
            .drawCircle(x, y, outerRadius)
            .beginHole()
            .drawCircle(x, y, innerRadius)
            .endHole();
    }
    this.finishPoly();
    this
        .arc(x, y, innerRadius, endArc, startArc, true)
        .arc(x, y, outerRadius, startArc, endArc, false)
        .finishPoly();
    return this;
}

/**
 * Draw Rectangle with chamfer corners. These are angled corners.
 *
 * _Note: Only available with **@pixi/graphics-extras**._
 *
 * @method PIXI.Graphics#drawChamferRect
 * @param {number} x - Upper left corner of rect
 * @param {number} y - Upper right corner of rect
 * @param {number} width - Width of rect
 * @param {number} height - Height of rect
 * @param {number} chamfer - non-zero real number, size of corner cutout
 * @return {PIXI.Graphics} Returns self.
 */
function drawChamferRect(x, y, width, height, chamfer) {
    if (chamfer <= 0) {
        return this.drawRect(x, y, width, height);
    }
    var inset = Math.min(chamfer, Math.min(width, height) / 2);
    var right = x + width;
    var bottom = y + height;
    var points = [
        x + inset, y,
        right - inset, y,
        right, y + inset,
        right, bottom - inset,
        right - inset, bottom,
        x + inset, bottom,
        x, bottom - inset,
        x, y + inset ];
    // Remove overlapping points
    for (var i = points.length - 1; i >= 2; i -= 2) {
        if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {
            points.splice(i - 1, 2);
        }
    }
    return this.drawPolygon(points);
}

/**
 * Draw Rectangle with fillet corners. This is much like rounded rectangle
 * however it support negative numbers as well for the corner radius.
 *
 * _Note: Only available with **@pixi/graphics-extras**._
 *
 * @method PIXI.Graphics#drawFilletRect
 * @param {number} x - Upper left corner of rect
 * @param {number} y - Upper right corner of rect
 * @param {number} width - Width of rect
 * @param {number} height - Height of rect
 * @param {number} fillet - accept negative or positive values
 * @return {PIXI.Graphics} Returns self.
 */
function drawFilletRect(x, y, width, height, fillet) {
    if (fillet === 0) {
        return this.drawRect(x, y, width, height);
    }
    var maxFillet = Math.min(width, height) / 2;
    var inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
    var right = x + width;
    var bottom = y + height;
    var dir = inset < 0 ? -inset : 0;
    var size = Math.abs(inset);
    return this
        .moveTo(x, y + size)
        .arcTo(x + dir, y + dir, x + size, y, size)
        .lineTo(right - size, y)
        .arcTo(right - dir, y + dir, right, y + size, size)
        .lineTo(right, bottom - size)
        .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)
        .lineTo(x + size, bottom)
        .arcTo(x + dir, bottom - dir, x, bottom - size, size)
        .closePath();
}

/**
 * Draw a regular polygon where all sides are the same length.
 *
 * _Note: Only available with **@pixi/graphics-extras**._
 *
 * @method PIXI.Graphics#drawRegularPolygon
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} radius - Polygon radius
 * @param {number} sides - Minimum value is 3
 * @param {number} rotation - Starting rotation values in radians..
 * @return {PIXI.Graphics}
 */
function drawRegularPolygon(x, y, radius, sides, rotation) {
    if (rotation === void 0) { rotation = 0; }
    sides = Math.max(sides | 0, 3);
    var startAngle = (-1 * Math.PI / 2) + rotation;
    var delta = (Math.PI * 2) / sides;
    var polygon = [];
    for (var i = 0; i < sides; i++) {
        var angle = (i * delta) + startAngle;
        polygon.push(x + (radius * Math.cos(angle)), y + (radius * Math.sin(angle)));
    }
    return this.drawPolygon(polygon);
}

/**
 * Draw a regular polygon with rounded corners.
 *
 * _Note: Only available with **@pixi/graphics-extras**._
 *
 * @method PIXI.Graphics#drawRoundedPolygon
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} radius - Polygon radius
 * @param {number} sides - Minimum value is 3
 * @param {number} corner - Corner size in pixels.
 * @param {number} rotation - Starting rotation values in radians..
 * @return {PIXI.Graphics}
 */
function drawRoundedPolygon(x, y, radius, sides, corner, rotation) {
    if (rotation === void 0) { rotation = 0; }
    sides = Math.max((sides | 0), 3);
    if (corner <= 0) {
        return this.drawRegularPolygon(x, y, radius, sides, rotation);
    }
    var sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;
    corner = Math.min(corner, sideLength);
    var startAngle = (-1 * Math.PI / 2) + rotation;
    var delta = (Math.PI * 2) / sides;
    var internalAngle = ((sides - 2) * Math.PI) / sides / 2;
    for (var i = 0; i < sides; i++) {
        var angle = (i * delta) + startAngle;
        var x0 = x + (radius * Math.cos(angle));
        var y0 = y + (radius * Math.sin(angle));
        var a1 = angle + (Math.PI) + internalAngle;
        var a2 = angle - (Math.PI) - internalAngle;
        var x1 = x0 + (corner * Math.cos(a1));
        var y1 = y0 + (corner * Math.sin(a1));
        var x3 = x0 + (corner * Math.cos(a2));
        var y3 = y0 + (corner * Math.sin(a2));
        if (i === 0) {
            this.moveTo(x1, y1);
        }
        else {
            this.lineTo(x1, y1);
        }
        this.quadraticCurveTo(x0, y0, x3, y3);
    }
    return this.closePath();
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } } };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * Draw a star shape with an arbitrary number of points.
 *
 * @ignore
 */
var Star = /** @class */ (function (_super) {
    __extends(Star, _super);
    /**
     * @param x - Center X position of the star
     * @param y - Center Y position of the star
     * @param points - The number of points of the star, must be > 1
     * @param radius - The outer radius of the star
     * @param innerRadius - The inner radius between points, default half `radius`
     * @param rotation - The rotation of the star in radians, where 0 is vertical
     */
    function Star(x, y, points, radius, innerRadius, rotation) {
        if (rotation === void 0) { rotation = 0; }
        var _this = this;
        innerRadius = innerRadius || radius / 2;
        var startAngle = (-1 * Math.PI / 2) + rotation;
        var len = points * 2;
        var delta = PI_2 / len;
        var polygon = [];
        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;
            polygon.push(x + (r * Math.cos(angle)), y + (r * Math.sin(angle)));
        }
        _this = _super.call(this, polygon) || this;
        return _this;
    }
    return Star;
}(Polygon));
/**
 * Draw a star shape with an arbitrary number of points.
 *
 * _Note: Only available with **@pixi/graphics-extras**._
 *
 * @method PIXI.Graphics#drawStar
 * @param x - Center X position of the star
 * @param y - Center Y position of the star
 * @param points - The number of points of the star, must be > 1
 * @param radius - The outer radius of the star
 * @param innerRadius - The inner radius between points, default half `radius`
 * @param rotation - The rotation of the star in radians, where 0 is vertical
 * @return - This Graphics object. Good for chaining method calls
 */
function drawStar(x, y, points, radius, innerRadius, rotation) {
    if (rotation === void 0) { rotation = 0; }
    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));
}

// Assign extras to Graphics
Object.defineProperties(Graphics.prototype, {
    drawTorus: { value: drawTorus },
    drawChamferRect: { value: drawChamferRect },
    drawFilletRect: { value: drawFilletRect },
    drawRegularPolygon: { value: drawRegularPolygon },
    drawRoundedPolygon: { value: drawRoundedPolygon },
    drawStar: { value: drawStar },
});
//# sourceMappingURL=graphics-extras.js.map
